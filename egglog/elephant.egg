(sort Expr)
(sort ExprVec (Vec Expr))
(sort IVec (Vec i64))

(constructor Wire (String i64) Expr)
(constructor Reg (String i64) Expr)
(constructor Mux (Expr Expr) Expr)
(constructor Demux (Expr Expr) Expr)
(constructor And (Expr Expr) Expr)
(constructor Or (Expr Expr) Expr)
(constructor Not (Expr) Expr)
(constructor Select (i64 Expr) Expr :cost 1000)
(constructor MapSelect (i64 ExprVec) Expr)
(constructor SelectFromVec (IVec Expr) Expr)
(constructor Concat (Expr Expr) Expr)
(constructor Read (Expr ExprVec) Expr)

(constructor Nand (Expr Expr) Expr)
(constructor Nor (Expr Expr) Expr)
(constructor Xor (Expr Expr) Expr)
(constructor SRLatch (Expr Expr) Expr)

(datatype Port
  (ReadPort Expr ExprVec ExprVec)
  (WritePort Expr Expr Expr)
  (WritePortMask Expr Expr Expr Expr))
(sort ReadPorts (Vec Port))
(sort WritePorts (Vec Port))

(datatype Opt
  (LatchLastRead)
  (WriteReadForward)
  (Sync))
(sort Opts (Vec Opt))

(datatype Memory (Mem ReadPorts WritePorts Opts))

(datatype Type
  (Bitvector i64))

(relation HasType (Expr Type))

(ruleset typing)

(rule
  ((Wire name n))
  ((HasType (Wire name n) (Bitvector n)))
  :ruleset typing)

(rule
  ((Reg name n))
  ((HasType (Reg name n) (Bitvector n)))
  :ruleset typing)

(rule
  ((Not a)
   (HasType a (Bitvector 1)))
  ((HasType (Not a) (Bitvector 1)))
  :ruleset typing)

(rule
  ((And a b)
   (HasType a (Bitvector 1))
   (HasType b (Bitvector 1)))
  ((HasType (And a b) (Bitvector 1)))
  :ruleset typing)

(rule
  ((Or a b)
   (HasType a (Bitvector 1))
   (HasType b (Bitvector 1)))
  ((HasType (Or a b) (Bitvector 1)))
  :ruleset typing)

(rule
  ((Select i a)
   (HasType a (Bitvector bw))
   (>= i 0)
   (< i bw))
  ((HasType (Select i a) (Bitvector 1)))
  :ruleset typing)

(rule
 ((Concat a b)
  (HasType a (Bitvector n))
  (HasType b (Bitvector m)))
 ((HasType (Concat a b) (Bitvector (+ n m))))
 :ruleset typing)

(rule
 ((MapSelect i wv))
 ((HasType (MapSelect i wv) (Bitvector (vec-length wv))))
 :ruleset typing)

(rule
 ((SelectFromVec iv w))
 ((HasType (SelectFromVec iv w) (Bitvector (vec-length iv))))
 :ruleset typing)

(rule
  ((Mux s i)
   (HasType s (Bitvector m))
   (HasType i (Bitvector n))
   (= m (log2 n)))
  ((HasType (Mux s i) (Bitvector 1)))
  :ruleset typing)

(rule
  ((Demux s i)
   (HasType s (Bitvector 1))
   (HasType i (Bitvector n))
   (= n (log2 m)))
  ((HasType (Demux s i) (Bitvector m)))
  :ruleset typing)

(rule
  ((Nand a b)
   (HasType a (Bitvector 1))
   (HasType b (Bitvector 1)))
  ((HasType (Nand a b) (Bitvector 1)))
  :ruleset typing)

(rule
  ((Nor a b)
   (HasType a (Bitvector 1))
   (HasType b (Bitvector 1)))
  ((HasType (Nor a b) (Bitvector 1)))
  :ruleset typing)

(rule
  ((SRLatch a b)
   (HasType a (Bitvector 1))
   (HasType b (Bitvector 1)))
  ((HasType (SRLatch a b) (Bitvector 1)))
  :ruleset typing)

(rule
  ((Xor a b)
   (HasType a (Bitvector 1))
   (HasType b (Bitvector 1)))
  ((HasType (Xor a b) (Bitvector 1)))
  :ruleset typing)






(ruleset decomp)
;; 2-to-1 mux
;; s a b <--> (a & ~s) | (b & s)
(rule
 ((= mux (Or e0 e1))
  (= e0 (And a (Not s)))
  (= e1 (And b s)))
 ((union mux (Mux s (Concat a b))))
 :ruleset decomp)

(rewrite
 (Or a b)
 (Or b a)
 :ruleset decomp)
(rewrite
 (And a b)
 (And b a)
 :ruleset decomp)

(rule
 ((= m_a (Mux s a))
  (HasType s (Bitvector n_s))
  (HasType a (Bitvector n_a))
  (= m_b (Mux s b))
  (HasType b (Bitvector n_b))
  (= n_a n_b)
  (= m_c (Mux s0 (Concat m_a m_b))))
 ((union m_c
   (Mux (Concat s s0) (Concat a b))))
 :ruleset decomp)

(rewrite
 (Concat (Select i a) (Select i b))
 (MapSelect i (vec-of a b))
 :ruleset decomp)

(rewrite
 (Concat (MapSelect i a) (MapSelect i b))
 (MapSelect i (vec-append a b))
 :ruleset decomp)

(rewrite
 (Select i a)
 (SelectFromVec (vec-of i) a)
 :ruleset decomp)

(rewrite
 (Concat (SelectFromVec i a) (SelectFromVec j a))
 (SelectFromVec (vec-append i j) a)
 :ruleset decomp)

(rule
 ((Not (And a b)))
 ((union (Not (And a b)) (Nand a b)))
 :ruleset decomp)

 (rule
 ((Not (Or a b)))
 ((union (Not (Or a b)) (Nor a b)))
 :ruleset decomp)

 (rule
 ((Or (And (Not a) b) (And a (Not b))))
 ((union (Or (And (Not a) b) (And a (Not b))) (Xor a b)))
 :ruleset decomp)

(rule
 ((= Q (Nor r Q_bar))
  (= Q_bar (Nor Q s)))
 ((union Q (SRLatch r s)))
 :ruleset decomp)
